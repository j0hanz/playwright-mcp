import { z } from 'zod';

import type { ToolContext } from './types.js';

export function registerTestTools(ctx: ToolContext): void {
  const { server, createToolHandler, logger } = ctx;

  // Create Test Plan Tool
  server.registerTool(
    'test_plan_create',
    {
      title: 'Create Test Plan',
      description:
        'Create a structured test plan in Markdown format. Used by the Playwright Test Planner agent.',
      inputSchema: {
        name: z
          .string()
          .describe(
            'Test plan name (e.g., Authentication Flow, Shopping Cart)'
          ),
        description: z.string().describe('High-level description of the test plan'),
        scenarios: z
          .array(
            z.object({
              title: z.string(),
              steps: z.array(z.string()),
              expected: z.string(),
            })
          )
          .describe('List of test scenarios'),
      },
      outputSchema: {
        success: z.boolean(),
        path: z.string(),
        filename: z.string(),
      },
    },
    createToolHandler(async ({ name, description, scenarios }) => {
      const { promises: fs } = await import('fs');

      const safeFileName = name.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
      const filePath = `specs/${safeFileName}.md`;

      const content = `# ${name}

> ${description}

## Test Scenarios

${scenarios
  .map(
    (s, i) => `### ${i + 1}. ${s.title}

**Steps:**
${s.steps.map((step) => `- ${step}`).join('\n')}

**Expected Result:**
${s.expected}
`
  )
  .join('\n')}
`;

      await fs.mkdir('specs', { recursive: true });
      await fs.writeFile(filePath, content, 'utf-8');

      return {
        content: [
          {
            type: 'text' as const,
            text: `Test plan created: ${filePath}`,
          },
        ],
        structuredContent: {
          success: true,
          path: filePath,
          filename: `${safeFileName}.md`,
        },
      };
    }, 'Error creating test plan')
  );

  // Create Test File Tool
  server.registerTool(
    'test_file_create',
    {
      title: 'Create Test File',
      description:
        'Create a Playwright test specification file generated by the Playwright Test Generator agent',
      inputSchema: {
        name: z
          .string()
          .describe(
            'Test file name (e.g., add-todo, login-valid). Will be saved as tests/{name}.spec.ts'
          ),
        content: z.string().describe('TypeScript test file content'),
      },
      outputSchema: {
        success: z.boolean(),
        path: z.string(),
        filename: z.string(),
      },
    },
    createToolHandler(async ({ name, content }) => {
      const { promises: fs } = await import('fs');

      const safeFileName = name.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
      const filePath = `tests/${safeFileName}.spec.ts`;

      await fs.mkdir('tests', { recursive: true });
      await fs.writeFile(filePath, content, 'utf-8');

      return {
        content: [
          {
            type: 'text' as const,
            text: `Test file created: ${filePath}`,
          },
        ],
        structuredContent: {
          success: true,
          path: filePath,
          filename: `${safeFileName}.spec.ts`,
        },
      };
    }, 'Error creating test file')
  );

  // Update Test File Tool
  server.registerTool(
    'test_file_update',
    {
      title: 'Update Test File',
      description:
        'Update an existing Playwright test file. Used by the Healer agent to fix failing tests.',
      inputSchema: {
        path: z
          .string()
          .describe(
            'Relative path to test file (e.g., tests/add-todo.spec.ts)'
          ),
        content: z.string().describe('Updated test file content'),
        reason: z
          .string()
          .optional()
          .describe('Reason for update (e.g., "Fixed broken locator")'),
      },
      outputSchema: {
        success: z.boolean(),
        path: z.string(),
        updated: z.boolean(),
      },
    },
    createToolHandler(async ({ path: filePath, content, reason }) => {
      const { promises: fs } = await import('fs');

      await fs.writeFile(filePath, content, 'utf-8');

      logger.info('Test file updated', {
        path: filePath,
        reason: reason || 'no reason provided',
      });

      return {
        content: [
          {
            type: 'text' as const,
            text: `Test file updated: ${filePath}${reason ? ` (${reason})` : ''}`,
          },
        ],
        structuredContent: {
          success: true,
          path: filePath,
          updated: true,
        },
      };
    }, 'Error updating test file')
  );

  // Read Test File Tool
  server.registerTool(
    'test_file_read',
    {
      title: 'Read Test File',
      description:
        'Read the content of a test specification file. Used by agents to understand existing tests.',
      inputSchema: {
        path: z
          .string()
          .describe(
            'Relative path to test file (e.g., tests/add-todo.spec.ts, specs/login-flow.md)'
          ),
      },
      outputSchema: {
        success: z.boolean(),
        path: z.string(),
        content: z.string(),
        lines: z.number(),
      },
    },
    createToolHandler(async ({ path: filePath }) => {
      const { promises: fs } = await import('fs');

      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n').length;

      return {
        content: [
          {
            type: 'text' as const,
            text: `Read ${filePath} (${lines} lines)`,
          },
        ],
        structuredContent: {
          success: true,
          path: filePath,
          content,
          lines,
        },
      };
    }, 'Error reading test file')
  );

  // List Test Artifacts Tool
  server.registerTool(
    'test_artifacts_list',
    {
      title: 'List Test Artifacts',
      description:
        'List all test plans and test files in the project. Returns specs/ and tests/ directories.',
      inputSchema: {
        type: z
          .enum(['all', 'specs', 'tests'])
          .default('all')
          .describe('Which artifacts to list'),
      },
      outputSchema: {
        success: z.boolean(),
        specs: z.array(z.string()),
        tests: z.array(z.string()),
        total: z.number(),
      },
    },
    createToolHandler(async ({ type }) => {
      const { promises: fs } = await import('fs');

      const specs: string[] = [];
      const tests: string[] = [];

      try {
        if (type === 'all' || type === 'specs') {
          const specsDir = 'specs';
          try {
            const files = await fs.readdir(specsDir);
            specs.push(...files.filter((f) => f.endsWith('.md')));
          } catch {
            // specs directory might not exist yet
          }
        }

        if (type === 'all' || type === 'tests') {
          const testsDir = 'tests';
          try {
            const files = await fs.readdir(testsDir);
            tests.push(...files.filter((f) => f.endsWith('.spec.ts')));
          } catch {
            // tests directory might not exist yet
          }
        }
      } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        logger.error('Error listing test artifacts', {
          error: err.message,
        });
      }

      const total = specs.length + tests.length;

      return {
        content: [
          {
            type: 'text' as const,
            text: `Found ${specs.length} test plan(s) and ${tests.length} test file(s)`,
          },
        ],
        structuredContent: {
          success: true,
          specs,
          tests,
          total,
        },
      };
    }, 'Error listing test artifacts')
  );

  // Delete Test Artifact Tool
  server.registerTool(
    'test_artifact_delete',
    {
      title: 'Delete Test Artifact',
      description: 'Delete a test plan or test file',
      inputSchema: {
        path: z
          .string()
          .describe(
            'Relative path to artifact (e.g., specs/login-flow.md, tests/add-todo.spec.ts)'
          ),
      },
      outputSchema: {
        success: z.boolean(),
        deleted: z.boolean(),
        path: z.string(),
      },
    },
    createToolHandler(async ({ path: filePath }) => {
      const { promises: fs } = await import('fs');

      try {
        await fs.unlink(filePath);
        logger.info('Test artifact deleted', { path: filePath });

        return {
          content: [
            {
              type: 'text' as const,
              text: `Deleted: ${filePath}`,
            },
          ],
          structuredContent: {
            success: true,
            deleted: true,
            path: filePath,
          },
        };
      } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        return {
          content: [
            {
              type: 'text' as const,
              text: `Failed to delete ${filePath}: ${err.message}`,
            },
          ],
          structuredContent: {
            success: false,
            deleted: false,
            path: filePath,
          },
        };
      }
    }, 'Error deleting test artifact')
  );
}
